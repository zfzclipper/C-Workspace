*Tail Recursion
(1)The use of ONLY ONE recursive call at the VERY END of a function implementation.
	(a)When the function call is made, there are NO statements left to be executed by the function;
	(b)The recursive call is not only the last statement, but there are NO earlier recursive calls, direct or indirect;
(2)Tail recursion could be replaced by one loop.

*Sorting
(1)It is often necessary to sort data before processing.
(2)The first step is to choose the criteria that will be used to order data.
(3)Two critical properties of sorting algorithms:
	(a)Number of comparisons;
	(b)Number of data movements;

--------------
| Quick Sort |
--------------
Divide-and-Conquer Recursive Algorithm;
Time Complexity: O(n*log(n));
Worst Case Performance: O(n^2);
*We can achieve quicksort’s fast running time on almost all inputs, with heapsort’s O(N log N) worst-case running time.

[+]Unlike merge-sort, the height of the quick-sort tree associated with an execution of quick-sort is linear in the worst case.
	if the sequence consists of n distinct elements and is already sorted

Divide the whole sequence into sub-sequences, recur to sort each subsequence, and then combine the sorted subsequences by a simple concatenation.
[1]Divide: Remove all the elements from S and put them into three sequences:
		(1)L: storing the elements in S less than x;
		(2)E: storing the elements in S equal to x;
		(3)G: storing the elements in S greater than x;
[2]Recur: Recursively sort sequences L and G.
[3]Conquer: Put back the elements into S in order by first inserting the elements of L, then those of E, and finally those of G. 



--------------
| Merge Sort |
--------------
Divide-and-Conquer Recursive Algorithm;
Time Complexity: O(n*log(n));

Implementation:
[+]List-based Recursive Algorithm
[+]Vector-based Recursive Algorithm
[ ]Vector-based Non-recursive Algorithm

Divide-and-Conquer Approach:
(1)Divide: Break the problem into several subproblems that are similar to the original problem but smaller in size;
(2)Conquer: Solve the subproblems recursively;
(3)Combine: Combine these solutions to create a solution to the original problem;


------------------
| Insertion Sort |
------------------
Time Complexity: O(n^2);
Insertion sort consists of N − 1 passes. 
Invariant: at each pass p <- [1, N-1], elements in positions 0 through p − 1 are already in sorted order.

[+]It sorts the array only when it is really necessary.
	If the array is already in order: only the variable tmp is initialized, and the value stored in it is moved back to the same position.
[-]Insertion is not localized: it may require moving a significant number of elements.
	If an item is being inserted, all elements greater than the one being inserted have to be moved. 
[-]The number of movements and comparisons for a randomly ordered array is closer to the worst case O(n^2).


------------------
| Selection Sort |
------------------
Time Complexity: O(n^2);
Invariant: at each pass, the smallest element in the unsorted sub-array is selected and swapped with the first position in unsorted sub-array.
[+]The required number of assignments is the best compared with any other algorithm.


---------------
| Bubble Sort |
---------------
Time Complexity: O(n^2);
[-]In the average case, approximately twice as many comparisons, and the same number of moves as insertion sort
			as many comparisons, and n times more moves than selection sort.
[-]Insertion sort is twice as fast as bubble sort.

